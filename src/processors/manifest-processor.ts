import fs from "node:fs/promises";
import { type Manifest, manifestPageFromDocument } from "../manifest";
import { type Processor } from "../processor";
import { haveOutput } from "../utils";
import { isDocumentPage } from "../document";

type ManifestPage = Manifest["pages"][number];

/**
 * Options for {@link manifestProcessor}.
 *
 * @public
 */
export interface ManifestProcessorOptions {
    /** If set, the manifest will be written as Markdown to this destination */
    markdown?: string;

    /** If set, the manifest will be written as JSON to this destination */
    json?: string;

    /** If set to `true` the markdown manifest will be verified instead of
     * written (typically enabled during CI) */
    verify?: boolean;
}

function line(page: ManifestPage): string {
    if (page.redirect) {
        return `${page.path} -> ${page.redirect}`;
    }
    return page.path;
}

function renderMarkdown(manifest: Manifest): string {
    return [
        "## Documentation manifest",
        "",
        "> Do not edit this file. It is a automatically generated by `@forsakringskassan/docs-generator`.",
        "",
        "```",
        ...manifest.pages.map(line),
        "```",
        "",
    ].join("\n");
}

function renderJSON(manifest: Manifest): string {
    return JSON.stringify(manifest, null, 2);
}

function normalize(text: string): string {
    return text.replace(/\r\n/g, "\n");
}

class ManifestError extends Error {
    private readonly filename: string;

    public constructor(filename: string) {
        super(`Documentation manifest "${filename}" is not up-to-date!`);
        this.filename = filename;
    }

    public prettyError(): string {
        const { filename, message } = this;

        return [
            message,
            "",
            `Run the build locally and commit the content of "${filename}".`,
        ].join("\n");
    }
}

/**
 * Write out a manifest listing all generated documents that will be present in
 * `outputFolder`.
 *
 * @public
 */
export function manifestProcessor(
    options: ManifestProcessorOptions = {},
): Processor {
    const { markdown, json, verify } = options;
    return {
        name: "manifestProcessor",
        before: "render",
        async handler(context) {
            const docs = context.docs.filter(isDocumentPage).filter(haveOutput);
            const pages = docs.map(manifestPageFromDocument);
            pages.sort((a, b) => {
                return a.path.localeCompare(b.path);
            });
            const manifest: Manifest = { pages };
            if (markdown) {
                const content = normalize(renderMarkdown(manifest));
                if (verify) {
                    const actual = normalize(
                        await fs.readFile(markdown, "utf-8"),
                    );
                    if (actual !== content) {
                        throw new ManifestError(markdown);
                    }
                } else {
                    await fs.writeFile(markdown, content, "utf-8");
                }
            }
            if (json) {
                const content = renderJSON(manifest);
                await fs.writeFile(json, content, "utf-8");
            }
        },
    };
}
